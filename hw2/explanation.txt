The flow.c code is designed to execute commands, including piping, concatenation, and error handling through flow-based logic, 
where each node represents a command or set of commands, and pipes define how data flows from one node to another. 
The flow file is parsed to build a structure, after which specific commands are executed based on user input. 
The key elements of this program are nodes, pipes, and concatenates.

Key Data Structures
Node: Represents an individual command.


typedef struct {
    char name[50];
    char command[100];
} Node;
Each node holds a name and the actual shell command to be executed.

PipeNode: Represents the connection between two nodes, indicating how the output of one node is piped into another.


typedef struct {
    char name[50];
    char from[50];
    char to[50];
} PipeNode;
StderrNode: Similar to PipeNode, but specifically for capturing and redirecting stderr.


typedef struct {
    char name[50];
    char from[50];
} StderrNode;
Concatenate: Represents a sequence of commands to be executed one after another.


typedef struct {
    char name[50];
    int num_parts;
    char parts[MAX_PARTS][50];
} Concatenate;
Core Functions

parse_flow_file(const char filename)**: This function reads the flow file and populates the Node, PipeNode, StderrNode, and Concatenate structures.
 Based on the file's content, it differentiates between these elements and assigns the necessary data.
Reads each line and categorizes it based on the type (node, pipe, stderr, concatenate).
Updates the corresponding arrays (nodes, pipes, stderr_nodes, concatenates).

get_node_command(const char node_name): Finds the shell command corresponding to the given node name.
Loops through the nodes array, comparing node_name with each stored node's name.
If found, returns the corresponding command.

get_stderr_source_command(const char stderr_name): Similar to get_node_command, but looks for a stderr-related node.

is_concatenate(const char name): Checks whether a given name corresponds to a Concatenate node.

execute_command(const char command): Forks a child process to execute a given shell command using execlp.
Forks a new process using fork().
The child process replaces itself with the shell process to run the command using execlp.
The parent process waits for the child to finish.

execute_piped_command(const char command1, const char command2): This handles piping between two commands.
Creates a pipe using pipe().
Forks two child processes: one to execute the first command and send its output to the pipe, and the other to read from the pipe and execute the second command.
The parent process closes the pipe and waits for both children to finish.

build_concatenate_command(const char concat_name, char result): Builds a string of concatenated commands. 
It loops through the parts of the concatenate and appends each part to the result string.

execute_node(const char node_name): Determines whether the node_name is a regular node, pipe, or concatenate and executes the corresponding command.
It first checks if the node is a simple Node.
Then, it checks if the node is a PipeNode and builds a pipe command.
Lastly, it checks if it's a Concatenate and builds the corresponding command.
Once the command is constructed, it executes it using execute_command().

Test Cases

Test Case 1
Command: ls | wc
Flow Command: ./flow filecount.flow doit
Explanation:
The flow file filecount.flow defines two nodes: list_files (ls) and word_count (wc).
The pipe doit connects list_files to word_count, which mirrors the ls | wc command.
Expected output is the line, word, and character count of the output from ls.

Test Case 2
Command: cat foo.txt ; cat foo.txt | sed 's/o/u/g'
Flow Command: ./flow complicated.flow foo_then_fuu
Explanation:
The node cat_foo executes cat foo.txt.
The node sed_o_u executes sed 's/o/u/g' to replace 'o' with 'u'.
The concatenate foo_then_fuu ensures cat foo.txt and cat foo.txt | sed 's/o/u/g' are run in sequence.
Expected output includes the content of foo.txt followed by its transformed version.

Test Case 3
Command: (cat foo.txt ; cat foo.txt | sed 's/o/u/g') | wc
Flow Command: ./flow complicated.flow shenanigan
Explanation:
The pipe shenanigan takes the output from foo_then_fuu and pipes it into wc.
It counts the lines, words, and characters in the concatenated output of the cat and sed commands.

Test Case 4
Command: Sequence of operations on numbers (seq 1 10).
Flow Command: ./flow comprehensive.flow number_operations
Explanation:
The Concatenate number_operations runs a sequence of commands: generating numbers (seq 1 10), sorting them, summing them, and calculating their product.
The expected output includes the sorted numbers, the sum (Sum: 55), and the product (Product: 3628800).

Test Case 5
Command: Sequence of operations on words (echo "apple banana ...") followed by counting and transforming the words to uppercase.
Flow Command: ./flow comprehensive.flow word_operations
Explanation:
The Concatenate word_operations performs a series of commands: echoing a list of words, counting them, and transforming them to uppercase.
The expected output includes the original words, the count of each word, and their uppercase versions.

Test Case 6
Command: seq 1 10 | sort -nr
Flow Command: ./flow comprehensive.flow numbers_to_reverse_sort
Explanation:
The pipe numbers_to_reverse_sort connects the generate_numbers node (which runs seq 1 10) to the reverse_sort_numbers node (which runs sort -nr to reverse sort).
Expected output is the numbers in reverse order.

Test Case 7
Command: mkdir test_directory | wc
Flow Command: ./flow error_handling.flow catch_errors
Explanation:
This test demonstrates error handling by capturing and counting output related to directory creation.
Expected output shows the result of wc after the mkdir command.